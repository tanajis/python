

What is a 'Greedy algorithm'?
Ref : https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/
-------------------------------------------------------------------------------------------------------------

1.A greedy algorithm, as the name suggests, always makes the choice that seems to be the best at that moment(min / max). 
2.locally-optimal choice(No garantee that it will lead to globally optimized solution).
3.Only one shot.It never goes back and reverses the decision.
4.We need sort some inputs by increasing or descresing order and then select.
5.It builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit

Greedy algorithms have some advantages and disadvantages:

1.Easy  to come up with a greedy algorithm  for a problem.
2.Analyzing the run time  will generally be much easier than for other techniques 
3.It is hard to prove why it is correct. 
4.Note: Most greedy algorithms are not correct. An example is described later in this article.

C. How to create a Greedy Algorithm?

Example :

Being a very busy person, you have exactly T time to do some interesting things and you want to do maximum such things.
You are given an array A of integers, where each element indicates the time a thing takes for completion. You want to calculate the maximum number of things that you can do in the limited time that you have.
This is a simple Greedy-algorithm problem. In each iteration, you have to greedily select the things which will take the minimum amount of time to complete while maintaining two variables currentTime and numberOfThings. To complete the calculation, you must:

Greedy approach:

Sort the array A in a non-decreasing order.
Select each to-do item one-by-one.
Add the time that it will take to complete that to-do item into currentTime.
Add one to numberOfThings.
Repeat this as long as the currentTime is less than or equal to T.

Let A = {5, 3, 4, 2, 1} and T = 6

After sorting, A = {1, 2, 3, 4, 5}

After the 1st iteration:

currentTime = 1
numberOfThings = 1
After the 2nd iteration:

currentTime is 1 + 2 = 3
numberOfThings = 2
After the 3rd iteration:

currentTime is 3 + 3 = 6
numberOfThings = 3
After the 4th iteration, currentTime is 6 + 4 = 10, which is greater than T. Therefore, the answer is 3.



#-------------------------------------------------------------------------------------------------------------------
Travelling Salesman Problem
Prim's Minimal Spanning Tree Algorithm
Kruskal's Minimal Spanning Tree Algorithm
Dijkstra's Minimal Spanning Tree Algorithm
Graph - Map Coloring
Graph - Vertex Cover
Knapsack Problem
Job Scheduling Problem

Activity Selection
N meetings in one room
Coin Piles
Maximize Toys
Page Faults in LRU
Largest number possible
Minimize the heights
Minimize the sum of product
Huffman Decoding
Minimum Spanning Tree
Shop in Candy Store
Geek collects the balls
